## incomplete type

```cpp
#include <cstdint>
#include <type_traits>

enum class VertexAttributeBit : uint32_t
{
    None     = 0x00000000,
    Position = 0x00000001,
    UV0      = 0x00000002,
    ALL      = 0x00000003,
};

#pragma once

#include <vector>

template<typename BitType>
class BitMask
{
public:
    using UnderlyingType = typename std::underlying_type<BitType>::type;

    constexpr BitMask() noexcept
        : m_mask(0)
    {}

    constexpr BitMask(BitType bit) noexcept
        : m_mask(static_cast<UnderlyingType>(bit))
    {}

    constexpr BitMask(BitMask<BitType> const& rhs) noexcept = default;

    constexpr explicit BitMask(UnderlyingType mask) noexcept
        : m_mask(mask)
    {}

    // This line cause Compilation failed in msvc
    // use of undefined type 'BitMask<VertexAttributeBit>'
    inline static BitMask<BitType> all_mask = static_cast<BitMask<BitType>>(BitType::ALL);

    // This line pass Compilation
    // inline static UnderlyingType all_mask = static_cast<UnderlyingType>(BitType::ALL);

private:
    UnderlyingType m_mask;
};

int main() { BitMask<VertexAttributeBit> attr; }
```

最终发现是这一行的问题

虽然不知道为什么我在 gcc 里面都可以编译

但是现在既然换成了 msvc，那么就还是跟着他来吧

## pointer to memebr

调用栈

```cpp
reflect::AddClass<ModelComponent>("ModelComponent")
    .AddArray("m_image_paths", "std::vector<std::string>", "std::string", &ModelComponent::m_image_paths);
```

```cpp
template<typename ArrayType>
TypeDescriptorBuilder& AddArray(const std::string& name,
                                const std::string& type_name,
                                const std::string& inner_type_name,
                                ArrayType ClassType::*array_ptr)
{
    m_type_descriptor.AddArray(ArrayAccessor(name, type_name, inner_type_name, array_ptr));
    return *this;
}
```

然后这里报错

```cpp
E:\repositories\MeowEngine\src\meow_runtime\core\reflect\type_descriptor_builder.hpp(38,57): error C2440: “<function-style-cast>”: 无法从“initializer list”转换为“Meow::reflect::ArrayAccessor” [E:\repositories\MeowEngine\build-
debug\src\meow_runtime\MeowRuntime.vcxproj]
  (编译源文件“../../../../src/meow_runtime/generated/register_all.cpp”)
      E:\repositories\MeowEngine\src\meow_runtime\core\reflect\type_descriptor_builder.hpp(38,57):
      “Meow::reflect::ArrayAccessor::ArrayAccessor”: 函数不接受 4 个参数
          E:\repositories\MeowEngine\src\meow_runtime\core\reflect\reflect.hpp(62,13):
          可能是“Meow::reflect::ArrayAccessor::ArrayAccessor(const std::string &,const std::string &,const std::string &,ArrayType<InnerType> ClassType::* )”
          E:\repositories\MeowEngine\src\meow_runtime\core\reflect\type_descriptor_builder.hpp(38,57):
          尝试匹配参数列表“(const std::string, const std::string, const std::string, ArrayType Meow::ModelComponent::* )”时
          with
          [
              ArrayType=std::vector<std::string,std::allocator<std::string>>
          ]
      E:\repositories\MeowEngine\src\meow_runtime\core\reflect\type_descriptor_builder.hpp(38,57):
      模板实例化上下文(最早的实例化上下文)为
          E:\repositories\MeowEngine\src\meow_runtime\generated\register_all.cpp(24,4):
          查看对正在编译的函数 模板 实例化“Meow::reflect::TypeDescriptorBuilder<Meow::ModelComponent> &Meow::reflect::TypeDescriptorBuilder<Meow::ModelComponent>::AddArray<std::vector<std::string,std::allocator<std::string>>>(const std
  ::string &,const std::string &,const std::string &,ArrayType Meow::ModelComponent::* )”的引用
          with
          [
              ArrayType=std::vector<std::string,std::allocator<std::string>>
          ]
              E:\repositories\MeowEngine\src\meow_runtime\generated\register_all.cpp(24,13):
              请参阅 "Meow::RegisterAll" 中对 "Meow::reflect::TypeDescriptorBuilder<Meow::ModelComponent>::AddArray" 的第一个引用
```

可能是函数类型不匹配……？

或者单纯是推导不了

但是明明 gcc 也是可以推导的

于是还是把模板类型改成简单的

```cpp
template<typename ClassType, typename InnerType>
ArrayAccessor(const std::string&     name,
                const std::string&     type_name,
                const std::string&     inner_type_name,
                std::vector<InnerType> ClassType::*array_ptr)
```

## j 未声明的标识符

```cpp
    void Model::LoadSkin(std::unordered_map<size_t, ModelVertexSkin>& skin_info_map,
                         ModelMesh*                                   mesh,
                         const aiMesh*                                ai_mesh,
                         const aiScene*                               ai_scene)
    {
        std::unordered_map<size_t, size_t> bone_index_map;

        for (size_t i = 0; i < (size_t)ai_mesh->mNumBones; ++i)
        {
            aiBone*     bone_info = ai_mesh->mBones[i];
            std::string bone_name(bone_info->mName.C_Str());
            size_t      bone_index = bones_map[bone_name]->index;

            // bone在mesh中的索引
            size_t mesh_bone_index = 0;
            auto   it              = bone_index_map.find(bone_index);
            if (it == bone_index_map.end())
            {
                mesh_bone_index = (size_t)mesh->bones.size();
                mesh->bones.push_back(bone_index);
                bone_index_map.insert(std::make_pair(bone_index, mesh_bone_index));
            }
            else
            {
                mesh_bone_index = it->second;
            }

            // 收集被Bone影响的顶点信息
            for (size_t j = 0; j < bone_info->mNumWeights; ++j)
            {
                size_t vertexID = bone_info->mWeights[j].mVertexId;
                float  weight   = bone_info->mWeights[j].mWeight;
                // 顶点->Bone
                if (skin_info_map.find(vertexID) == skin_info_map.end())
                {
                    skin_info_map.insert(std::make_pair(vertexID, ModelVertexSkin()));
                }
                ModelVertexSkin* info     = &(skin_info_map[vertexID]);
                info->indices[info->used] = mesh_bone_index;
                info->weights[info->used] = weight;
                info->used += 1;
                // 只允许最多四个骨骼影响顶点
                if (info->used >= 4)
                {
                    break;
                }
            }
        }
```

最后发现是编码的问题

vscode中保存为utf-8,然后MSVC中国大陆地区默认用gbk导致的

## error C2589: “(”:“::”右边的非法标记

看上去是 max 的问题

但是我已经定义了 NOMINMAX 仍然报错

于是把这个定义定在了 public 上

```cmake
target_compile_definitions(${RUNTIME_NAME} PUBLIC
  NOMINMAX) # for std::numeric_limits<double>::min() and max()
```

然后就没错了

看上去 public 是可以传播给第三方库？