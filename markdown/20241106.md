## 离屏渲染

别人是，渲染场景就是用自己的 `render pass`

离屏渲染的纹理作为 `framebuffer`

发现这个最终 `RefreshFrameBuffers` 的纹理我是默认 `swapchain` 传入

或许需要改一下

然后看到 `ImGuiVulkanHppImage` 里面的 `FrameRender` 都是直接用 `wd` 的 `swapchain` 和 `framebuffer`

我在想要不要跟着他的做……

不过最后觉得还是一样的

比如我一开始还是这样写

```cpp
    void EditorWindow::CreateSwapChian()
    {
        const vk::raii::Instance&       vulkan_instance = g_runtime_context.render_system->GetInstance();
        const vk::raii::PhysicalDevice& physical_device = g_runtime_context.render_system->GetPhysicalDevice();
        const vk::raii::Device&         logical_device  = g_runtime_context.render_system->GetLogicalDevice();
        const uint32_t graphics_queue_family_index = g_runtime_context.render_system->GetGraphicsQueueFamiliyIndex();

        m_igmui_window.Surface = *m_surface_data.surface;

        m_igmui_window.SurfaceFormat = PickSurfaceFormat(physical_device.getSurfaceFormatsKHR(*m_surface_data.surface));
        m_igmui_window.PresentMode   = static_cast<VkPresentModeKHR>(
            PickPresentMode(physical_device.getSurfacePresentModesKHR(*m_surface_data.surface)));

        ImGui_ImplVulkanH_CreateOrResizeWindow(**vulkan_instance,
                                               **physical_device,
                                               **logical_device,
                                               &m_igmui_window,
                                               graphics_queue_family_index,
                                               nullptr,
                                               m_surface_data.extent.width m_surface_data.extent.height,
                                               k_max_frames_in_flight);
    }
```

这样 `ImGui_ImplVulkanH_CreateOrResizeWindow` 会不会有什么特别的……

进去看确实没有什么特别的

那么唯一能够导致不同的确实就是， editor pass 不用 swapchain image 而是 imgui pass 来用 swapchain 

于是还是需要重来