## 资源系统

我发现还是要限制一下资源系统的自由度

Load 类的函数就是接受一个文件地址的

然后维护一个文件地址对应 uuid 的 map

然后 unload 的时候就再删减这个 map

get 的时候应该拿 uuid 来查，而不是用文件地址来查

因为之后要添加一个创建本地资源的功能

之前是根据文件地址这个字符串来找资源，现在你增加内置资源的时候，就没有文件地址这个东西了，那你要用什么来分别不同的本地资源呢

如果是自己再给本地资源加一个命名的话，你还需要每一次创建本地资源时传入的名字不同，如果是内部创建名字的话，首先你就要根据传入的资源是什么来创建不同的字符串，或者也是单纯的不看种类，单纯在返回值里面放一个与之前的资源都不同的字符串

但是这样的话，这个传出的字符串仅仅是起到标识的作用，完全就看上去很多余

还不如直接用一个 uuid 来辨识资源

那么既然都有了 uuid，那就没有必要再用字符串来分别了

然后程序内部在查找资源的时候，就只用 uuid 来查找

然后资源系统里面会有一份资源的 shared ptr

即使是没有任何一个地方用到这个资源，他也不会被销毁，只能是程序退出时资源系统析构，或者是手动删除这个 shared ptr 导致资源释放

手动删除就通过 uuid 来做

这样就完成了 Load 和 Unload

那么如果我全部都用 cpp 来写的话，我自然是可以注意其他地方只存 uuid

但是如果是从编辑器拖拽文件的这种方式呢

我觉得应该是，拖拽的时候就是传入文件地址，然后会尝试 load，所以 load 里面需要检查这个文件地址是否已经 load 过了，如果没有，那么加载，返回 uuid，如果有，那么直接返回 uuid

那么这里就需要一个 string 指向 uuid 的 map

然后但是你要通过 uuid 来查资源 shared ptr，所以这也需要一个 map

那么在 shared_ptr 销毁的时候，对应的这个 string 指向 uuid 的 map 中对应的条目也要销毁

好吧，甚至是即使是不考虑这个 string 指向 uuid 的 map，单看 uuid 指向 shared_ptr 的 map 中对应的条目也要销毁

但是问题是你不知道 shared_ptr 什么时候销毁

虽然你可以做一些侵入式的设计，比如在你自己的代码里面有类 A，那么在 A 的构造和析构里面使用订阅观察者模式，来通知资源系统删除这个条目，但是很丑……

好吧，这么想是无稽之谈，因为不是因为 shared_ptr 引用计数 0 了才去销毁 uuid 指向 shared_ptr 的 map 中对应的条目

而是别人调用了 Unload，传入 uuid，删除 uuid 指向 shared_ptr 的 map 中对应的条目，然后 shared_ptr 释放了，就这样

要关心的是别的事情，比如怎么删除 string 指向 uuid 的 map 中对应的条目

那就好办了，直接在 Unload 里面一起处理就好了

因为可能直接从 ModelComponent 拖动，来实现一个资源共享，所以要在 Model Component 里面也加 uuid

至于其他地方的 uuid 有效性管理，就交给后面吧，比如如果我不删这个 ModelComponent 但是单独删掉这个 Model 的 shared_ptr 的时候，那么这个肯定是一个单独的函数来完成，里面肯定也是考虑这些，所以不需要我忧心