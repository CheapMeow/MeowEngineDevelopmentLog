- [构建](#构建)
- [渲染数据结构](#渲染数据结构)
  - [图像数据类 ImageData](#图像数据类-imagedata)
  - [渲染通道 Render Pass](#渲染通道-render-pass)
    - [信息依赖](#信息依赖)
    - [多个 Render Pass 与单独一个 Render Pass 多个 subpass 之前的区别](#多个-render-pass-与单独一个-render-pass-多个-subpass-之前的区别)
    - [结构设计](#结构设计)
      - [pending command](#pending-command)
    - [其他](#其他)
      - [附件不需要为 frames in flight 而备份](#附件不需要为-frames-in-flight-而备份)
- [常见错误](#常见错误)
  - [CreateInfo 可能引用了局部变量](#createinfo-可能引用了局部变量)
  - [从 RAII 类转型成非 RAII 类](#从-raii-类转型成非-raii-类)
  - [Ring buffer 的大小](#ring-buffer-的大小)
  - [在 stl 容器中使用 vk 类](#在-stl-容器中使用-vk-类)
  - [使用之前先 Reset](#使用之前先-reset)

## 构建

使用 `file(GLOB_RECURSE ...)` 获取文件列表的方法不值得采纳，因为 CMake 是一个构建系统生成器，而不是构建系统。

`GLOB_RECURSE` 是在构建的时候生成文件列表，那么 CMake 在生成构建系统的时候就没有办法知道文件列表，也就没有办法利用文件信息

比如我觉得是因为他没有办法利用时间戳，才导致每次都要重新构建

所以想要增量构建，还是直接在 CMakeLists 里面直接给出所有文件的列表更稳妥

我不想手动维护所有文件列表，所以写了一个 python 脚本，递归获取指定文件夹下以特定后缀为结尾的所有文件

然后再用 cmake-format 来格式化

我在想……为什么不直接写到 bat 里面

做一个 CMakeLists.template 获取文件列表，替换进去，产生 CMakeList，还能加个格式化

## 渲染数据结构

### 图像数据类 ImageData

不同的图像所包含的渲染数据类型是一样的，都是 `vk::raii::Image` `vk::raii::ImageView` `vk::raii::Sampler` 那些

但是不同的图像的创建配置，图像布局的转换会不一样

所以使用工厂模式来创建图像

### 渲染通道 Render Pass

#### 信息依赖

更改渲染通道，例如做延迟渲染的时候，我需要某一个 pass 输出到三个纹理附件，然后下一个 pass 使用这三个纹理附件

那么 render pass 和 frame buffer 都需要更改

render pass 需要知道：

1.各个 subpass 总共要使用到的所有附件的信息

通过 `vk::AttachmentDescription` 存储

2.各个 subpass 对附件集合的引用。正如其名，是一个引用，或者说索引

通过 `vk::AttachmentReference` 存储

之后 subpass 就通过 `vk::AttachmentReference` 来知道，自己使用的是前面 `vk::AttachmentDescription` 中的第几个

3.每一个 subpass 是什么，每一个 subpass 使用的附件

通过 `vk::SubpassDescription` 存储

比如你是什么额外操作都没有，那么就只有一个单独的 subpass

但是比如延迟渲染的话，就需要两个 subpass，一个是输出颜色、法线、深度，一个是读取这些附件做着色

4.每个 subpass 之间的依赖关系

通过 `vk::SubpassDependency` 存储

比如延迟渲染的第二个 pass 需要依赖第一个 pass 的各个附件都输出完

5.最终汇总上面所有的信息，制作一个 render pass

通过 `vk::RenderPassCreateInfo` 存储

render pass 和 frame buffer 都需要知道附件信息

render pass 要知道的是附件的配置，而 frame buffer 要保存附件的 `vk::raii::ImageView` 引用

因为其实是 render pass 决定了附件的配置，所以 frame buffer 应该是 render pass 的数据成员

因为 frame buffer 要保存附件的 `vk::raii::ImageView` 引用，所以 `vk::raii::ImageView` 应该是 frame buffer 的成员

但是既然已经有 `vk::raii::Framebuffer` 了，那我觉得让 `vk::raii::Framebuffer` 和 `vk::raii::ImageView` 平级，都属于 render pass 也无所谓

#### 多个 Render Pass 与单独一个 Render Pass 多个 subpass 之前的区别

如果 command 提交过程中你需要切换 framebufferview，则你需要一个新的 renderpass(vkBeginRenderPass),这是 renderpass 的作用。

而 subpass 则是一种加速手段。如果你的 shader 要读取上一个 pass 的输出，并且只读取当前 uv 位置的数据，则可以在 shader 中使用 InputAttachment.load,在满足一定条件下，subpass 可以直接从片上缓存读取到上一个 pass 的输出。

作者：qbkivlin
链接：https://www.zhihu.com/question/469595919/answer/1979478299
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#### 结构设计

Pipeline 的创建需要知道颜色附件的信息，存储在 `vk::PipelineColorBlendAttachmentState`

一个颜色附件对应一个 `vk::PipelineColorBlendAttachmentState`

`vk::PipelineColorBlendStateCreateInfo` 汇总这些 `vk::PipelineColorBlendAttachmentState`

也就是 Material 创建 Pipeline 的时候，需要知道对应 subpass 的附件信息

因此 Material 应该是附属于 subpass 的数据结构

一个 render pass 的各个 subpass 应该是独立的类实例

```cpp
DeferredPass::DeferredPass(vk::raii::PhysicalDevice const& physical_device,
                            vk::raii::Device const&         device,
                            SurfaceData&                    surface_data,
                            vk::raii::CommandPool const&    command_pool,
                            vk::raii::Queue const&          queue,
                            DescriptorAllocatorGrowable&    m_descriptor_allocator)
{
    // Create a set to store all information of attachments

    vk::Format color_format =
        PickSurfaceFormat((physical_device).getSurfaceFormatsKHR(*surface_data.surface)).format;
    assert(color_format != vk::Format::eUndefined);

    std::vector<vk::AttachmentDescription> attachment_descriptions;
    // swap chain attachment
    attachment_descriptions.emplace_back(vk::AttachmentDescriptionFlags(), /* flags */
                                          color_format,                     /* format */
                                          sample_count,                     /* samples */
                                          vk::AttachmentLoadOp::eClear,     /* loadOp */
                                          vk::AttachmentStoreOp::eStore,    /* storeOp */
                                          vk::AttachmentLoadOp::eDontCare,  /* stencilLoadOp */
                                          vk::AttachmentStoreOp::eDontCare, /* stencilStoreOp */
                                          vk::ImageLayout::eUndefined,      /* initialLayout */
                                          vk::ImageLayout::ePresentSrcKHR); /* finalLayout */
    // color attachment
    attachment_descriptions.emplace_back(vk::AttachmentDescriptionFlags(),          /* flags */
                                          color_format,                              /* format */
                                          sample_count,                              /* samples */
                                          vk::AttachmentLoadOp::eClear,              /* loadOp */
                                          vk::AttachmentStoreOp::eDontCare,          /* storeOp */
                                          vk::AttachmentLoadOp::eDontCare,           /* stencilLoadOp */
                                          vk::AttachmentStoreOp::eDontCare,          /* stencilStoreOp */
                                          vk::ImageLayout::eUndefined,               /* initialLayout */
                                          vk::ImageLayout::eColorAttachmentOptimal); /* finalLayout */
    // normal attachment
    attachment_descriptions.emplace_back(vk::AttachmentDescriptionFlags(),          /* flags */
                                          vk::Format::eR8G8B8A8Unorm,                /* format */
                                          sample_count,                              /* samples */
                                          vk::AttachmentLoadOp::eClear,              /* loadOp */
                                          vk::AttachmentStoreOp::eDontCare,          /* storeOp */
                                          vk::AttachmentLoadOp::eDontCare,           /* stencilLoadOp */
                                          vk::AttachmentStoreOp::eDontCare,          /* stencilStoreOp */
                                          vk::ImageLayout::eUndefined,               /* initialLayout */
                                          vk::ImageLayout::eColorAttachmentOptimal); /* finalLayout */
    // depth attachment
    attachment_descriptions.emplace_back(vk::AttachmentDescriptionFlags(),                 /* flags */
                                          depth_format,                                     /* format */
                                          sample_count,                                     /* samples */
                                          vk::AttachmentLoadOp::eClear,                     /* loadOp */
                                          vk::AttachmentStoreOp::eDontCare,                 /* storeOp */
                                          vk::AttachmentLoadOp::eDontCare,                  /* stencilLoadOp */
                                          vk::AttachmentStoreOp::eDontCare,                 /* stencilStoreOp */
                                          vk::ImageLayout::eUndefined,                      /* initialLayout */
                                          vk::ImageLayout::eDepthStencilAttachmentOptimal); /* finalLayout */

    // Create reference to attachment information set

    vk::AttachmentReference swapchain_attachment_reference(0, vk::ImageLayout::eColorAttachmentOptimal);

    std::vector<vk::AttachmentReference> color_attachment_references;
    color_attachment_references.emplace_back(1, vk::ImageLayout::eColorAttachmentOptimal);
    color_attachment_references.emplace_back(2, vk::ImageLayout::eColorAttachmentOptimal);

    vk::AttachmentReference depth_attachment_reference(3, vk::ImageLayout::eDepthStencilAttachmentOptimal);

    std::vector<vk::AttachmentReference> input_attachment_references;
    input_attachment_references.emplace_back(1, vk::ImageLayout::eShaderReadOnlyOptimal);
    input_attachment_references.emplace_back(2, vk::ImageLayout::eShaderReadOnlyOptimal);
    input_attachment_references.emplace_back(3, vk::ImageLayout::eShaderReadOnlyOptimal);

    // Create subpass

    std::vector<vk::SubpassDescription> subpass_descriptions;
    subpass_descriptions.push_back(vk::SubpassDescription(vk::SubpassDescriptionFlags(),    /* flags */
                                                          vk::PipelineBindPoint::eGraphics, /* pipelineBindPoint */
                                                          {},                               /* pInputAttachments */
                                                          color_attachment_references,      /* pColorAttachments */
                                                          {},                          /* pResolveAttachments */
                                                          &depth_attachment_reference, /* pDepthStencilAttachment */
                                                          nullptr));                   /* pPreserveAttachments */
    subpass_descriptions.push_back(vk::SubpassDescription(vk::SubpassDescriptionFlags(),    /* flags */
                                                          vk::PipelineBindPoint::eGraphics, /* pipelineBindPoint */
                                                          input_attachment_references,      /* pInputAttachments */
                                                          swapchain_attachment_reference,   /* pColorAttachments */
                                                          {},        /* pResolveAttachments */
                                                          {},        /* pDepthStencilAttachment */
                                                          nullptr)); /* pPreserveAttachments */

    // Create subpass dependency

    std::vector<vk::SubpassDependency> dependencies;
    dependencies.emplace_back(VK_SUBPASS_EXTERNAL,                               /* srcSubpass */
                              0,                                                 /* dstSubpass */
                              vk::PipelineStageFlagBits::eBottomOfPipe,          /* srcStageMask */
                              vk::PipelineStageFlagBits::eColorAttachmentOutput, /* dstStageMask */
                              vk::AccessFlagBits::eMemoryRead,                   /* srcAccessMask */
                              vk::AccessFlagBits::eColorAttachmentWrite,         /* dstAccessMask */
                              vk::DependencyFlagBits::eByRegion);                /* dependencyFlags */
    dependencies.emplace_back(0,                                                 /* srcSubpass */
                              1,                                                 /* dstSubpass */
                              vk::PipelineStageFlagBits::eColorAttachmentOutput, /* srcStageMask */
                              vk::PipelineStageFlagBits::eFragmentShader,        /* dstStageMask */
                              vk::AccessFlagBits::eColorAttachmentWrite,         /* srcAccessMask */
                              vk::AccessFlagBits::eShaderRead,                   /* dstAccessMask */
                              vk::DependencyFlagBits::eByRegion);                /* dependencyFlags */
    dependencies.emplace_back(1,                                                 /* srcSubpass */
                              VK_SUBPASS_EXTERNAL,                               /* dstSubpass */
                              vk::PipelineStageFlagBits::eColorAttachmentOutput, /* srcStageMask */
                              vk::PipelineStageFlagBits::eBottomOfPipe,          /* dstStageMask */
                              vk::AccessFlagBits::eColorAttachmentWrite,         /* srcAccessMask */
                              vk::AccessFlagBits::eMemoryRead,                   /* dstAccessMask */
                              vk::DependencyFlagBits::eByRegion);                /* dependencyFlags */

    // Create render pass
    vk::RenderPassCreateInfo render_pass_create_info(vk::RenderPassCreateFlags(), /* flags */
                                                      attachment_descriptions,     /* pAttachments */
                                                      subpass_descriptions,        /* pSubpasses */
                                                      dependencies);               /* pDependencies */

    render_pass = vk::raii::RenderPass(device, render_pass_create_info);

    // Create Material

    std::shared_ptr<Shader> obj_shader_ptr = std::make_shared<Shader>(physical_device,
                                                                      device,
                                                                      m_descriptor_allocator,
                                                                      "builtin/shaders/obj.vert.spv",
                                                                      "builtin/shaders/obj.frag.spv");

    obj2attachment_mat                        = Material(physical_device, device, obj_shader_ptr);
    obj2attachment_mat.color_attachment_count = 2;
    obj2attachment_mat.UpdateDescriptorSets(device);
    obj2attachment_mat.CreatePipeline(device, render_pass, vk::FrontFace::eClockwise, true);

    std::shared_ptr<Shader> quad_shader_ptr = std::make_shared<Shader>(physical_device,
                                                                        device,
                                                                        m_descriptor_allocator,
                                                                        "builtin/shaders/quad.vert.spv",
                                                                        "builtin/shaders/quad.frag.spv");

    quad_mat         = Material(physical_device, device, quad_shader_ptr);
    quad_mat.subpass = 1;
    quad_mat.CreatePipeline(device, render_pass, vk::FrontFace::eClockwise, true);

    // Create quad model
    std::vector<float>    vertices = {-1.0f, 1.0f,  0.0f, 0.0f, 0.0f, 1.0f,  1.0f,  0.0f, 1.0f, 0.0f,
                                      1.0f,  -1.0f, 0.0f, 1.0f, 1.0f, -1.0f, -1.0f, 0.0f, 0.0f, 1.0f};
    std::vector<uint16_t> indices  = {0, 1, 2, 0, 2, 3};

    quad_model = std::move(Model(physical_device,
                                  device,
                                  command_pool,
                                  queue,
                                  vertices,
                                  indices,
                                  quad_mat.shader_ptr->per_vertex_attributes));
}
```

例如这里的 `attachment_descriptions` `color_attachment_references` `input_attachment_references` 都应该是由各个 subpass 分别添加的

`subpass_descriptions` `dependencies` 更不用说了

各个 subpass 都添加完了之后，render pass 再 create

`VkClearValue` 也应该存储在 render pass 里面，一个 `VkClearValue` 对应一个 attachment

什么时候使用 `cmd_buffer.nextSubpass(vk::SubpassContents::eInline);` 也应该由 render pass 来决定，因为他知道自己有多少个 subpass 

##### pending command

因为使用了 subpass，pending command 的执行位置需要额外考虑了

例如我现在得到一个报错

```
[16:37:34] RUNTIME: Error: { Validation }:
        messageIDName   = <VUID-vkCmdPipelineBarrier-None-07889>
        messageIdNumber = -616663606
        message         = <Validation Error: [ VUID-vkCmdPipelineBarrier-None-07889 ] Object 0: handle = 0x9fde6b0000000014, type = VK_OBJECT_TYPE_RENDER_PASS; | MessageID = 0xdb3e75ca | vkCmdPipelineBarrier():  Barriers cannot be set during subpass 0 of VkRenderPass 0x9fde6b0000000014[] with no self-dependency specified. The Vulkan spec states: If vkCmdPipelineBarrier is called within a render pass instance using a VkRenderPass object, the render pass must have been created with at least one subpass dependency that expresses a dependency from the current subpass to itself, does not include VK_DEPENDENCY_BY_REGION_BIT if this command does not, does not include VK_DEPENDENCY_VIEW_LOCAL_BIT if this command does not, and has synchronization scopes and access scopes that are all supersets of the scopes defined in this command (https://vulkan.lunarg.com/doc/view/1.3.275.0/windows/1.3-extensions/vkspec.html#VUID-vkCmdPipelineBarrier-None-07889)>
        Objects:
                Object 0
                        objectType   = RenderPass
                        objectHandle = 11519762544604479508
```

这个报错的意思是，如果我在某个 subpass 里面做 `vkCmdPipelineBarrier`，那么这个 render pass 中应该有一个 subpass dependency， `srcSubpass` `dstSubpass` 都是这个 subpass 自己

如果真的要这么做，就有点复杂了我觉得。在自定义类里面，render pass 还要去管 command buffer 的事，有点耦合了。

他看上去就像是，其实可以不在 render pass 里面做 `vkCmdPipelineBarrier`

那么我为什么要这么做呢。因为我以前的遇到过错误是，command buffer 的使用需要在 command buffer 的录制阶段，然后我一看我的代码，只有 render pass 的 begin 和 end 之间有写 command buffer 的 begin 和 end，所以我就把所有跟 command buffer 有关的执行都存储起来，统一推迟到 render pass 里面执行，以此实现位于 command buffer 的 begin 和 end 之间

现在我才突然发现，其实 command buffer 的 begin 和 end 跟 render pass 没有关系，倒不如说是为了 `cmd_buffer.beginRenderPass` 才需要启动 command buffer 的录制

或许其实 command buffer 它本身就是一个 buffer，所以理论上就是要随时录制的，我这么做再加多一层肯定有问题

所以我把那个 pending command 删了，要用到 command buffer 的地方直接录制就好了

之后再看 command buffer 的使用，发现它的使用方法真的和我的想法一模一样。submit 之前，记录的命令就一直留在 command buffer 里面，submit 之后用 reset 清空就好了

我之前都是在 render pass 的记录之前清空，那是因为简单案例里面，render pass 前面没有 command buffer 相关的其他东西

现在搞懂之后觉得，应该是 submit 之后，wait for fence 结束之后 reset 最合理

这样，一帧里面的所有命令都保存下来了

#### 其他

##### 附件不需要为 frames in flight 而备份

[Why is a single depth buffer sufficient for multiple frames in flight?](https://www.reddit.com/r/vulkan/comments/aavxl4/why_is_a_single_depth_buffer_sufficient_for/)

[What exactly is the definition of "frames in flight"?](https://www.reddit.com/r/vulkan/comments/nbu94q/what_exactly_is_the_definition_of_frames_in_flight/)

虽然我们有飞行中的多个帧 multiple frames in flight，但是这并不意味着我们在同时渲染多个帧

实际上，multiple frames in flight 的意思是，一个帧具有三个阶段

1. 记录命令缓冲，上传数据
   
2. GPU 渲染

3. 呈现到屏幕

我们可以有两个帧同时位于不同的阶段，但是我们不会有两个帧同时位于同一个阶段

所以我们在给 frame buffer 提供 `vk::raii::ImageView` 引用的时候，多个 frame buffer 引用不同的 swapchain 的 image view，但是引用同一个深度缓冲

那么如果你再添加其他附件，也是无需为了多个 frame buffer 而备份的

## 常见错误

### CreateInfo 可能引用了局部变量

比如某个 `CreateInfo` 需要 `&BufferInfo`

这个 `BufferInfo` 是当前函数的局部变量

在当前函数中创建完 `CreateInfo`，并不是立即使用，而是存到 `vector` 中留待后用

那么在离开函数的时候，`BufferInfo` 销毁，存在 `vector` 中的 `CreateInfo` 就出错了

别人引用了局部变量 `BufferInfo` 怎么没出错？因为他们创建出来 `CreateInfo` 之后就立即使用了

### 从 RAII 类转型成非 RAII 类

从 RAII 类转型成非 RAII 类，并且使用 `std::move` 来移动资源所有权，这种方法不一定能达成转移资源的目的

例如：

```cpp
// header file
std::vector<vk::DescriptorSet> descriptor_sets;

// source file
vk::DescriptorSetAllocateInfo descriptor_set_allocate_info(
    *descriptor_pool, descriptorSetLayouts.size(), descriptorSetLayouts.data());
vk::raii::DescriptorSets raii_descriptor_sets(logical_device, descriptor_set_allocate_info);

for (size_t i = 0; i < raii_descriptor_sets.size(); ++i)
{
    descriptor_sets.push_back(*std::move(raii_descriptor_sets[i]));
}
```

关键在于转型到的非 RAII 类并不是出于 RAII 的目的设计的，所以可能不会提供移动构造函数，这样，即使使用了 `std::move`，其实仍然是把 `std::move` 产生的左值当作右值传给了拷贝构造函数

而拷贝构造函数一般只是共享了这个资源。因此，在离开作用域之后，RAII 类析构，其中的资源没有转移，因此就析构掉了资源，同时非 RAII 类即使没有被析构，其中的资源也已经无效了

### Ring buffer 的大小

不知道为什么，给负责存储 uniform buffer data 的 Ring buffer 分配 32 KB 就没问题，但是分配 32MB 就会很卡

### 在 stl 容器中使用 vk 类

有些 vk 类没有实现移动构造和拷贝构造，用于 stl 容器中会，在容器扩容的时候会丢失数据，例如 `vk::WriteDescriptorSet`

### 使用之前先 Reset

比如 `QueryPool` 我确实是在 BeginQuery 之前 Reset 了，但是我是单独开一个 command buffer 的 begin 和 end 包裹这个 Reset，不是和开启 render pass 的 command buffer 的 begin 和 end 一起，这也会出现错误，还必须要在一起